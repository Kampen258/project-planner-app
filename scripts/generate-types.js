#!/usr/bin/env node

/**
 * Generate TypeScript types from Supabase
 * Based on latest best practices 2025
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const PROJECT_ID = process.env.VITE_SUPABASE_PROJECT_ID || 'msuqglhbfritslvytexf';
const OUTPUT_PATH = './src/lib/database.types.ts';

console.log('üîÑ Generating TypeScript types from Supabase...');
console.log(`üìç Project ID: ${PROJECT_ID}`);
console.log(`üìÅ Output: ${OUTPUT_PATH}`);

try {
  // Generate types using Supabase CLI
  const command = `npx supabase gen types typescript --project-id "${PROJECT_ID}"`;
  const types = execSync(command, { encoding: 'utf8' });

  // Add custom header with generation timestamp
  const header = `// This file is automatically generated from your Supabase schema
// Last generated: ${new Date().toISOString()}
// Generated using: ${command}
//
// Do not edit this file directly. Instead, update your database schema
// and regenerate types using: npm run generate-types

`;

  // Add advanced utility types and constants
  const footer = `
// Advanced utility types for better DX
type DatabaseWithoutInternals = Omit<Database, "__InternalSupabase">
type DefaultSchema = DatabaseWithoutInternals[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? (DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof DatabaseWithoutInternals },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof DatabaseWithoutInternals },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof DatabaseWithoutInternals
  }
    ? keyof DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends {
  schema: keyof DatabaseWithoutInternals
}
  ? DatabaseWithoutInternals[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

// Convenience type aliases for common tables
export type Project = Tables<"projects">
export type ProjectInsert = TablesInsert<"projects">
export type ProjectUpdate = TablesUpdate<"projects">

export type Task = Tables<"tasks">
export type TaskInsert = TablesInsert<"tasks">
export type TaskUpdate = TablesUpdate<"tasks">

export type User = Tables<"users">
export type UserInsert = TablesInsert<"users">
export type UserUpdate = TablesUpdate<"users">

export type TeamMember = Tables<"team_members">
export type TeamMemberInsert = TablesInsert<"team_members">
export type TeamMemberUpdate = TablesUpdate<"team_members">

// Type-safe database relationships
export type ProjectWithTasks = Project & {
  tasks: Task[]
}

export type TaskWithProject = Task & {
  project: Project
}

// Utility types for RPC functions
export type RpcParams<T extends keyof Database['public']['Functions']> =
  Database['public']['Functions'][T]['Args']

export type RpcReturn<T extends keyof Database['public']['Functions']> =
  Database['public']['Functions'][T]['Returns']

// Constants for enum values (useful for dropdowns/validation)
export const DatabaseConstants = {
  ProjectStatus: ["planning", "in_progress", "completed", "on_hold"] as const,
  TaskStatus: ["todo", "in_progress", "completed", "cancelled"] as const,
  TaskPriority: ["low", "medium", "high", "urgent"] as const,
  UserRole: ["owner", "admin", "member", "viewer"] as const,
} as const;

// Type guards for runtime validation
export const isValidProjectStatus = (status: string): status is Project['status'] =>
  DatabaseConstants.ProjectStatus.includes(status as any);

export const isValidTaskStatus = (status: string): status is Task['status'] =>
  DatabaseConstants.TaskStatus.includes(status as any);

export const isValidTaskPriority = (priority: string): priority is Task['priority'] =>
  DatabaseConstants.TaskPriority.includes(priority as any);
`;

  // Write the complete types file
  const finalTypes = header + types + footer;

  // Ensure directory exists
  const dir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(OUTPUT_PATH, finalTypes);

  console.log('‚úÖ TypeScript types generated successfully!');
  console.log(`üìä Generated ${finalTypes.split('\\n').length} lines of type definitions`);
  console.log('üéØ Features included:');
  console.log('   ‚Ä¢ Auto-generated from live database schema');
  console.log('   ‚Ä¢ Advanced utility types (Tables, TablesInsert, TablesUpdate)');
  console.log('   ‚Ä¢ Convenience type aliases');
  console.log('   ‚Ä¢ Type-safe RPC function support');
  console.log('   ‚Ä¢ Runtime type guards');
  console.log('   ‚Ä¢ Database constants for validation');

} catch (error) {
  console.error('‚ùå Failed to generate types:', error.message);

  if (error.message.includes('Authentication failed')) {
    console.error('');
    console.error('üîê Authentication required. Please:');
    console.error('   1. Login to Supabase CLI: npx supabase login');
    console.error('   2. Or set SUPABASE_ACCESS_TOKEN environment variable');
  }

  if (error.message.includes('Project not found')) {
    console.error('');
    console.error('üîç Project not found. Please:');
    console.error('   1. Check your project ID in .env file');
    console.error('   2. Ensure you have access to the project');
  }

  process.exit(1);
}